--- src/vnet/ip/ip6_hop_by_hop.c
+++ src/vnet/ip/ip6_hop_by_hop.c
@@ -1138,126 +1408,165 @@ ip6_local_hop_by_hop_inline (vlib_main_t * vm,
   next = nexts;
 
   while (n_left_from >= 4)
+  {
+    ip6_header_t *ip0, *ip1, *ip2, *ip3;
+    u8 *hbh0, *hbh1, *hbh2, *hbh3;
+
+    /* Prefetch next iteration. */
+    if (PREDICT_TRUE (n_left_from >= 8))
     {
-      ip6_header_t *ip0, *ip1, *ip2, *ip3;
-      u8 *hbh0, *hbh1, *hbh2, *hbh3;
+      vlib_prefetch_buffer_header (b[4], STORE);
+      vlib_prefetch_buffer_header (b[5], STORE);
+      vlib_prefetch_buffer_header (b[6], STORE);
+      vlib_prefetch_buffer_header (b[7], STORE);
+      CLIB_PREFETCH (b[4]->data, CLIB_CACHE_LINE_BYTES, STORE);
+      CLIB_PREFETCH (b[5]->data, CLIB_CACHE_LINE_BYTES, STORE);
+      CLIB_PREFETCH (b[6]->data, CLIB_CACHE_LINE_BYTES, STORE);
+      CLIB_PREFETCH (b[7]->data, CLIB_CACHE_LINE_BYTES, STORE);
+    }
 
-      /* Prefetch next iteration. */
-      if (PREDICT_TRUE (n_left_from >= 8))
-	{
-	  vlib_prefetch_buffer_header (b[4], STORE);
-	  vlib_prefetch_buffer_header (b[5], STORE);
-	  vlib_prefetch_buffer_header (b[6], STORE);
-	  vlib_prefetch_buffer_header (b[7], STORE);
-	  CLIB_PREFETCH (b[4]->data, CLIB_CACHE_LINE_BYTES, STORE);
-	  CLIB_PREFETCH (b[5]->data, CLIB_CACHE_LINE_BYTES, STORE);
-	  CLIB_PREFETCH (b[6]->data, CLIB_CACHE_LINE_BYTES, STORE);
-	  CLIB_PREFETCH (b[7]->data, CLIB_CACHE_LINE_BYTES, STORE);
-	}
+    /*
+      * Leave current_data pointing at the IP header.
+      * It's reasonably likely that any registered handler
+      * will want to know where to find the ip6 header.
+      */
+    ip0 = vlib_buffer_get_current (b[0]);
+    ip1 = vlib_buffer_get_current (b[1]);
+    ip2 = vlib_buffer_get_current (b[2]);
+    ip3 = vlib_buffer_get_current (b[3]);
+
+    /* Look at hop-by-hop header */
+    hbh0 = ip6_next_header (ip0);
+    hbh1 = ip6_next_header (ip1);
+    hbh2 = ip6_next_header (ip2);
+    hbh3 = ip6_next_header (ip3);
+
+    /*
+    * ... to find the next header type and see if we
+    * have a handler for it...
+    */
+    next[0] = rt->next_index_by_protocol[*hbh0];
+    next[1] = rt->next_index_by_protocol[*hbh1];
+    next[2] = rt->next_index_by_protocol[*hbh2];
+    next[3] = rt->next_index_by_protocol[*hbh3];
+
+    b[0]->error = unknown_proto_error;
+    b[1]->error = unknown_proto_error;
+    b[2]->error = unknown_proto_error;
+    b[3]->error = unknown_proto_error;
+
+    /* Account for non-drop pkts */
+    ok += next[0] != 0;
+    ok += next[1] != 0;
+    ok += next[2] != 0;
+    ok += next[3] != 0;
+
+    if (is_trace)
+    {
+      if (b[0]->flags & VLIB_BUFFER_IS_TRACED)
+      {
+        ip6_local_hop_by_hop_trace_t *t =
+        vlib_add_trace (vm, node, b[0], sizeof (*t));
+        t->next_index = next[0];
+        t->protocol = *hbh0;
+      }
+      if (b[1]->flags & VLIB_BUFFER_IS_TRACED)
+      {
+        ip6_local_hop_by_hop_trace_t *t =
+        vlib_add_trace (vm, node, b[1], sizeof (*t));
+        t->next_index = next[1];
+        t->protocol = *hbh1;
+      }
+      if (b[2]->flags & VLIB_BUFFER_IS_TRACED)
+      {
+        ip6_local_hop_by_hop_trace_t *t =
+        vlib_add_trace (vm, node, b[2], sizeof (*t));
+        t->next_index = next[2];
+        t->protocol = *hbh2;
+      }
+      if (b[3]->flags & VLIB_BUFFER_IS_TRACED)
+      {
+        ip6_local_hop_by_hop_trace_t *t =
+        vlib_add_trace (vm, node, b[3], sizeof (*t));
+        t->next_index = next[3];
+        t->protocol = *hbh3;
+      }
+    }
 
-      /*
-       * Leave current_data pointing at the IP header.
-       * It's reasonably likely that any registered handler
-       * will want to know where to find the ip6 header.
-       */
-      ip0 = vlib_buffer_get_current (b[0]);
-      ip1 = vlib_buffer_get_current (b[1]);
-      ip2 = vlib_buffer_get_current (b[2]);
-      ip3 = vlib_buffer_get_current (b[3]);
-
-      /* Look at hop-by-hop header */
-      hbh0 = ip6_next_header (ip0);
-      hbh1 = ip6_next_header (ip1);
-      hbh2 = ip6_next_header (ip2);
-      hbh3 = ip6_next_header (ip3);
-
-      /*
-       * ... to find the next header type and see if we
-       * have a handler for it...
-       */
-      next[0] = rt->next_index_by_protocol[*hbh0];
-      next[1] = rt->next_index_by_protocol[*hbh1];
-      next[2] = rt->next_index_by_protocol[*hbh2];
-      next[3] = rt->next_index_by_protocol[*hbh3];
-
-      b[0]->error = unknown_proto_error;
-      b[1]->error = unknown_proto_error;
-      b[2]->error = unknown_proto_error;
-      b[3]->error = unknown_proto_error;
-
-      /* Account for non-drop pkts */
-      ok += next[0] != 0;
-      ok += next[1] != 0;
-      ok += next[2] != 0;
-      ok += next[3] != 0;
-
-      if (is_trace)
-	{
-	  if (b[0]->flags & VLIB_BUFFER_IS_TRACED)
-	    {
-	      ip6_local_hop_by_hop_trace_t *t =
-		vlib_add_trace (vm, node, b[0], sizeof (*t));
-	      t->next_index = next[0];
-	      t->protocol = *hbh0;
-	    }
-	  if (b[1]->flags & VLIB_BUFFER_IS_TRACED)
-	    {
-	      ip6_local_hop_by_hop_trace_t *t =
-		vlib_add_trace (vm, node, b[1], sizeof (*t));
-	      t->next_index = next[1];
-	      t->protocol = *hbh1;
-	    }
-	  if (b[2]->flags & VLIB_BUFFER_IS_TRACED)
-	    {
-	      ip6_local_hop_by_hop_trace_t *t =
-		vlib_add_trace (vm, node, b[2], sizeof (*t));
-	      t->next_index = next[2];
-	      t->protocol = *hbh2;
-	    }
-	  if (b[3]->flags & VLIB_BUFFER_IS_TRACED)
-	    {
-	      ip6_local_hop_by_hop_trace_t *t =
-		vlib_add_trace (vm, node, b[3], sizeof (*t));
-	      t->next_index = next[3];
-	      t->protocol = *hbh3;
-	    }
-	}
+    ioam_pop_hop_by_hop_processing (vm, ip0, (ip6_hop_by_hop_header_t *) hbh0, b[0]);
+    ioam_pop_hop_by_hop_processing (vm, ip1, (ip6_hop_by_hop_header_t *) hbh1, b[1]);
+    ioam_pop_hop_by_hop_processing (vm, ip2, (ip6_hop_by_hop_header_t *) hbh2, b[2]);
+    ioam_pop_hop_by_hop_processing (vm, ip3, (ip6_hop_by_hop_header_t *) hbh3, b[3]);
 
-      b += 4;
-      next += 4;
-      n_left_from -= 4;
+    /* In that case it is necessary to remove the IP header */
+    if (*hbh0 == IP_PROTOCOL_IPV6)
+    {
+      ip6_hop_by_hop_header_t *hbh_header = (ip6_hop_by_hop_header_t *) hbh0;
+      vlib_buffer_advance(b[0], (word) (40 + ((hbh_header->length + 1) << 3)));
     }
 
-  while (n_left_from > 0)
+    if (*hbh1 == IP_PROTOCOL_IPV6)
     {
-      ip6_header_t *ip0;
-      u8 *hbh0;
+      ip6_hop_by_hop_header_t *hbh_header = (ip6_hop_by_hop_header_t *) hbh1;
+      vlib_buffer_advance(b[1], (word) (40 + ((hbh_header->length + 1) << 3)));
+    }
 
-      ip0 = vlib_buffer_get_current (b[0]);
+    if (*hbh2 == IP_PROTOCOL_IPV6)
+    {
+      ip6_hop_by_hop_header_t *hbh_header = (ip6_hop_by_hop_header_t *) hbh2;
+      vlib_buffer_advance(b[2], (word) (40 + ((hbh_header->length + 1) << 3)));
+    }
 
-      hbh0 = ip6_next_header (ip0);
+    if (*hbh3 == IP_PROTOCOL_IPV6)
+    {
+      ip6_hop_by_hop_header_t *hbh_header = (ip6_hop_by_hop_header_t *) hbh3;
+      vlib_buffer_advance(b[3], (word) (40 + ((hbh_header->length + 1) << 3)));
+    }
 
-      next[0] = rt->next_index_by_protocol[*hbh0];
+    b += 4;
+    next += 4;
+    n_left_from -= 4;
+  }
 
-      b[0]->error = unknown_proto_error;
-      ok += next[0] != 0;
+  while (n_left_from > 0)
+  {
+    ip6_header_t *ip0;
+    u8 *hbh0;
 
-      if (is_trace)
-	{
-	  if (b[0]->flags & VLIB_BUFFER_IS_TRACED)
-	    {
-	      ip6_local_hop_by_hop_trace_t *t =
-		vlib_add_trace (vm, node, b[0], sizeof (*t));
-	      t->next_index = next[0];
-	      t->protocol = *hbh0;
-	    }
-	}
+    ip0 = vlib_buffer_get_current (b[0]);
 
-      b += 1;
-      next += 1;
-      n_left_from -= 1;
+    hbh0 = ip6_next_header (ip0);
+
+    next[0] = rt->next_index_by_protocol[*hbh0];
+
+    b[0]->error = unknown_proto_error;
+    ok += next[0] != 0;
+
+    if (is_trace)
+    {
+      if (b[0]->flags & VLIB_BUFFER_IS_TRACED)
+      {
+        ip6_local_hop_by_hop_trace_t *t =
+        vlib_add_trace (vm, node, b[0], sizeof (*t));
+        t->next_index = next[0];
+        t->protocol = *hbh0;
+      }
+    }
+
+    ioam_pop_hop_by_hop_processing (vm, ip0, (ip6_hop_by_hop_header_t *) hbh0, b[0]);
+
+    /* In that case it is necessary to remove the IP header */
+    if (*hbh0 == IP_PROTOCOL_IPV6)
+    {
+      ip6_hop_by_hop_header_t *hbh_header = (ip6_hop_by_hop_header_t *) hbh0;
+      vlib_buffer_advance(b[0], (word) (40 + ((hbh_header->length + 1) << 3)));
     }
 
+    b += 1;
+    next += 1;
+    n_left_from -= 1;
+  }
+
   vlib_buffer_enqueue_to_next (vm, node, from, nexts, frame->n_vectors);
 
   vlib_node_increment_counter (vm, node->node_index,
